# 驱动盘自动扫描逻辑推演

## 目标
从左上角第一个驱动盘开始，按照"从左到右，从上到下"的顺序，逐个点击并截图所有驱动盘。

## 流程设计

### 1. 检测已选中驱动盘
- **输入**: 当前屏幕截图
- **处理**: 使用CV识别"已选中的驱动盘"（黄色边框）
- **输出**: 
  - 外接矩形 `selected_rect` (x, y, w, h)
  - 中心点 `current_selected_disk` (x, y)
- **日志**: `检测到已选中驱动盘 (行, 列) 坐标(x, y)`

### 2. 截图保存
- **输入**: 当前屏幕截图
- **处理**: 保存截图到 `.debug/images/`
- **输出**: 截图文件路径
- **日志**: `截图已保存: 文件名`

### 3. 获取所有驱动盘方格
- **输入**: 当前屏幕截图
- **处理**: 
  1. 使用CV识别"驱动盘方格"（所有方格，包括或不包括当前选中的）
  2. 提取每个方格的中心点
  3. **关键**: 检查当前选中盘是否在列表中，如果不在则补充进去
  4. 对所有方格进行网格化排序
  5. 在排序后的网格中定位当前选中盘的 (row_idx, col_idx)
- **输出**: 
  - 所有方格列表 `all_disk_grids`
  - 当前位置 `(row_idx, col_idx)`
- **日志**: `当前位置: (行, 列) / 共 N 个方格`

### 4. 选择下一个驱动盘
- **输入**: 
  - 当前位置 `(row_idx, col_idx)`
  - 网格化的方格列表
- **处理**:
  1. 如果当前列 + 1 < 当前行的列数 → 点击同一行下一个
  2. 否则，如果当前行 + 1 < 总行数 → 点击下一行第一个
  3. 否则 → 扫描完成
- **输出**: 点击目标坐标
- **日志**: `当前 (行, 列) -> 点击 (行, 列)`

### 5. 循环
- 点击后等待 `click_interval` 秒
- 跳回步骤 1

## 关键问题诊断

### 问题1: 为什么一直停在"检测到已选中驱动盘"？
**可能原因**: 
- `@node_from` 装饰器配置错误，导致没有正确跳转到下一个节点
- 状态机没有正确连接各个节点

**解决方案**:
- 检查所有节点的 `@node_from` 装饰器
- 确保状态流转: 检测 → 截图 → 获取方格 → 选择下一个 → 检测（循环）

### 问题2: 为什么没有看到行列坐标的日志？
**可能原因**:
- 从未执行到"获取所有驱动盘方格"节点
- 节点执行了但返回了"重试"状态，导致跳回了上一个节点

**解决方案**:
- 在每个节点的入口和出口都添加详细日志
- 明确记录每个节点的执行路径和返回状态

## 代码结构问题

当前代码有个致命缺陷：
- `get_all_disk_grids` 只获取方格列表，不做任何定位
- `select_next_disk` 才进行定位和计算下一个
- 但是日志输出应该在 `get_all_disk_grids` 中，让用户知道当前定位到了哪个位置

## 修正方案

将定位逻辑前移到 `get_all_disk_grids`，在这个节点就完成：
1. 获取所有方格
2. 补充当前选中盘（如果需要）
3. 网格化排序
4. 定位当前位置 (row_idx, col_idx)
5. **输出日志: 当前位置 (行, 列)**

然后 `select_next_disk` 只负责：
1. 根据当前位置计算下一个目标
2. 点击
3. **输出日志: 当前 (行, 列) -> 点击 (行, 列)**